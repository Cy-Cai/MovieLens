---
title: "Recommendation System"
author: "Cyrus Cai"
date: "3/30/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
load("../rda/edx.rda")
load("../rda/train_set.rda")
load("../rda/test_set.rda")
```

# 1 Introduction
With the assumption that historical data contains inights for the future, we attempt to predict human behavior. The research is done in various areas, such as retail, movies, polls etc. 

## 1.1 The Chanllenge 
Today, I follow many processors and will build a recommendation system for movies. The model will predict what rating the exsiting user will give for a movie that he/she never watched before.

## 1.2 Dataset: MovieLens
I will use **MovieLens** as our dataset. The dataset is generated by GroupLens reseach lab. You can download the data through the [link](http://files.grouplens.org/datasets/movielens/ml-10m.zip).

```{r MovieLens head,echo=FALSE}
head(edx,5)
```

## 1.3 Goal
I will find a consice and yet accurate model. The project is aimed at an RMSE that is less than 0.865. The project is also aimed to produce an easy-to-follow and reproducible report. 

# 2 Analysis
Before modeling, I create two dataset: **edx** and **validation**. The **validation** is 10% of the full dataset, and is only used for final assessement of the model. It won't be used for anywhere else in the project. The **edx** data is going to be split into two subset, **train_set** and **test_set**.

## 2.1 The Simplest Model
The simplest model,  y_i=mu+e_i

```{r, echo=FALSE}
RMSE <- function(true_ratings,predicted_ratings){
  sqrt(mean((true_ratings-predicted_ratings)^2))
}
```

```{r}
mu<-mean(train_set$rating)
rmse_simplest_model <- RMSE(mu,test_set$rating)
```

### Performance

```{r,echo=FALSE}
rmse_results <- data.frame(method="Average",RMSE=rmse_simplest_model)
```

```{r}
rmse_results
```


### Pros
This modle is the simplest model.

### Cons
The histogram shows that majority of the movies have residual more than 1.

The scatter plot shows that the residual converts to 1 as the rating count increase.In other words, the more rating for a movie doesn't increase the prediction accuracy with this model.

Therefore, I need to consider movie as a factor for the next model.

```{r, echo=FALSE}
temp_p <- test_set %>% mutate(residul=(rating-mu)^2) %>% group_by(movieId) %>% 
  summarise(r=sqrt(mean(residul)),count=n()) 

temp_p  %>% 
  ggplot(aes(r))+geom_histogram(bins=20)+labs(x="Residual",y="Movie Count",title="Histogram Movie Count vs Residual")+  geom_vline(xintercept=1)

mean(temp_p$r>1)

 temp_p%>% 
  ggplot(aes(count,r))+geom_point() +labs(x="Rating Count by Movie",y="Residual",title="Scatter Plot Residual vs Rating Count ")

```

The histogram shows that majority of the users have residual more than 1

The scatter plot shows that the residual converts to 1 as the rating count increase.In other words, the more ratings from a user don't increase the prediction accuracy with this model. 

Therefore, I need to consider user as a factor for the next model.

```{r,echo=FALSE}
temp_p <- test_set %>% mutate(residul=(rating-mu)^2) %>% group_by(userId) %>% 
  summarise(r=sqrt(mean(residul)),count=n())

temp_p%>% 
  ggplot(aes(r))+geom_histogram(bins=20)+labs(x="Residual",y="User Count",title="Histogram User Count vs Residual")+  geom_vline(xintercept=1)

mean(temp_p$r>1)

temp_p %>% 
  ggplot(aes(count,r))+geom_point() +labs(x="Rating Count per User",y="Residual",title="Scatter Plot Residual vs Rating Count")

```


## 2.2 Model 2

The model that consider movie and user average rating,  y_ij=mu+m_i+u_i+e_ij.
m_i is average of the ratings for movie i. u_j is the average of the ratings
for movie j. eij is the random error of rating of movie i from user j.

```{r}
movie_avgs <- train_set %>% group_by(movieId) %>% 
  summarise(m_i=mean(rating-mu))

user_avgs <- train_set %>% left_join(movie_avgs,by="movieId") %>% 
  group_by(userId) %>% 
  summarise(u_i=mean(rating-mu-m_i))

predicted_rating <- test_set %>% left_join(movie_avgs,by="movieId") %>% 
  left_join(user_avgs,by="userId") %>% mutate(predicted_rating=mu+m_i+u_i) %>% 
  .$predicted_rating
rmse_MovieAndUserAverage <- RMSE(predicted_rating,test_set$rating)
```

```{r,echo=FALSE}
rmse_results <- rbind(rmse_results,
                      data.frame(method="Add Movie and User Average",RMSE=rmse_MovieAndUserAverage))
```


### Performance
The RMSE increase from 1.0606 to 0.8660. The accuracy improves siginificantly. But it does not reach my goal yet. 

```{r,echo=FALSE}
rmse_results
```

### Pros
The histogram shows that majority of the movies have residual less than 1.Thus, adding the movie factor improves the result.

```{r movie,echo=FALSE}
#by movie
temp_p <- test_set %>% left_join(movie_avgs,by="movieId") %>%
  left_join(user_avgs,by="userId") %>%
  mutate(predicted_rating=mu+m_i+u_i) %>%
  mutate(residul=(rating-predicted_rating)^2) %>%
  group_by(movieId) %>%
  summarise(r=sqrt(mean(residul)),count=n())
```
```{r movie histogram,echo=FALSE}
temp_p%>%
  ggplot(aes(r))+geom_histogram(bins=20)+labs(x="Residual",y="Movie Count",title="Histogram Movie Count vs Residual")+geom_vline(xintercept=1)

mean(temp_p$r>1)

```

The histogram shows that majority of the users have residual less than 1.Thus, adding the user factor improves the result.

```{r,echo=FALSE}
#by user
temp_p <- test_set %>% left_join(movie_avgs,by="movieId") %>%
  left_join(user_avgs,by="userId") %>%
  mutate(predicted_rating=mu+m_i+u_i) %>%
  mutate(residul=(rating-predicted_rating)^2) %>%
  group_by(userId) %>%
  summarise(r=sqrt(mean(residul)),count=n())

temp_p%>%
  ggplot(aes(r))+geom_histogram(bins=20)+labs(x="Residual",y="User Count",title="Histogram User Count vs Residual")+geom_vline(xintercept=1)

mean(temp_p$r>1)
```

### Cons

The bar chat shows that all the genres have residual greater than 1.

The scatter plot shows that the residual doesn't decrease as the rating count increase.In other words, the more ratings for a genre don't increase the prediction accuracy with this model.

Therefore, I need to consider the genre as a factor in the model 3.


```{r genres bar chart and scatter plot,echo=FALSE}
temp_p <- test_set %>% mutate(residul=(rating-mu)^2) %>% 
separate_rows(genres, sep = "\\|") %>% 
group_by(genres) %>% 
  summarise(r=sqrt(mean(residul)),count=n()) 

temp_p%>% ggplot(aes(genres,r))+geom_bar(stat = "identity") +
  labs(x="Genres",y="Residual",title="Bar Chart Residual vs Genres")+
  geom_text(aes(label=round(r,3)),size=3,check_overlap = TRUE,position=position_dodge(width=0.9), vjust=-0.25)+theme(axis.text.x = element_text(angle = 90, hjust = 1))


temp_p%>%  ggplot(aes(count,r))+geom_point() +
  labs(x="Rating Count per Genres",y="Residual",title="Scatter Plot Residual vs Rating Count")

```


## 2.3 Model 3
I call the third model *User Profile Model*. I will look at the user's historial rating record and identify the most rated genre. The genre will be marked as "Top 1", while any other genres will be marked as "Non-Top 1" for this user.

The underlying reasoning is: the user who like watching movies of certain genre gives an above-average rating to them. 

The model can be expressed as, y_ij=mu+m_i+u_j(genres)+e_ij, where u_j is a function of genres. 

```{r user profile, echo =FALSE}
genres_ref <- train_set %>% distinct(genres) %>% 
  mutate(genres2=genres) %>% 
  separate_rows(genres2, sep = "\\|") 

train_set_with_genres_breakdown <- train_set %>% left_join(genres_ref,by="genres") 
test_set_with_genres_breakdown <- test_set %>% left_join(genres_ref,by="genres") 

user_profile <- train_set_with_genres_breakdown %>% group_by(userId,genres2) %>% 
  summarise(count=n(),avg_rating=mean(rating),sd_rating=sd(rating),max_rating=max(rating),min_rating=min(rating)) %>% 
  mutate(Percent=count/sum(count))

top_genres_per_users <- user_profile%>% 
  group_by(userId) %>% 
  summarise(count=max(count)) %>% 
  mutate(rank="Top 1")
  
user_profile <- user_profile %>% left_join(top_genres_per_users,by=c("userId","count"))
user_profile$rank[is.na(user_profile$rank)]<-"Non-Top 1"

user_profile <- user_profile %>% 
              left_join(user_profile %>% 
              mutate(sum_rating=count*avg_rating) %>% 
              group_by(userId,rank) %>% 
              summarise(avg_rating_by_rank=sum(sum_rating)/sum(count)),by=c("userId","rank"))

user_profile_mean_by_rank <- user_profile %>% 
                            distinct(userId,rank,avg_rating_by_rank) %>% 
                            data.frame()
user_profile_rank_by_genres <- user_profile %>% select(userId,genres2,rank)

```

```{r}
movie_avgs <- train_set %>% group_by(movieId) %>% 
  summarise(m_i=mean(rating-mu))

user_profile_avgs <- train_set_with_genres_breakdown %>% 
  left_join(movie_avgs,by="movieId") %>% 
  left_join(user_profile_rank_by_genres,by=c("userId","genres2")) %>% 
  left_join(user_profile_mean_by_rank,by=c("userId","rank")) %>% 
  group_by(userId,rank) %>% 
  summarise(u_i=mean(rating-mu-m_i))

```

```{r rmse calculation, echo=FALSE }
predicted_rating <- test_set_with_genres_breakdown %>% 
  left_join(movie_avgs,by="movieId") %>% 
  left_join(user_profile_rank_by_genres,by=c("userId","genres2")) 


predicted_rating$rank[is.na(predicted_rating$rank)]="Non-Top 1"
 

predicted_rating <- predicted_rating %>% 
  left_join(user_profile_avgs,by=c("userId","rank")) %>%
  mutate(predicted_rating=mu+m_i+u_i) %>% 
  group_by(userId,movieId) %>% 
  summarise(predicted_rating=mean(predicted_rating))

temp<-test_set %>% left_join(predicted_rating,by=c("userId","movieId"))
rmse_MovieAndUserPrfileAverage <- RMSE(temp$predicted_rating,temp$rating)
rmse_results <- rbind(rmse_results,
                      data.frame(method="Add Movie and User Profile Average",RMSE=rmse_MovieAndUserPrfileAverage))
```

### Performance
```{r}
rmse_results
```
### Pros

The RMSE by genres drops below 0.9. There are only two genres with RMSE>0.9. 

The scatter plot shows that the accuracy is stable and mostly independent to the rating counts by genre. 

```{r bar chat, echo=FALSE}
temp_p <- temp %>% left_join(movie_avgs,by="movieId") %>%
  mutate(residul=(rating-predicted_rating)^2) %>%
  separate_rows(genres, sep = "\\|") %>%
  group_by(genres) %>%
  summarise(r=sqrt(mean(residul)),count=n())

temp_p%>% ggplot(aes(genres,r))+geom_bar(stat = "identity") +
  labs(x="Genres",y="Residual",title="Bar Chart Residual vs Genres")+
  geom_text(aes(label=round(r,3)),size=3,check_overlap=TRUE,position=position_dodge(width=0.9), vjust=-0.25)+theme(axis.text.x = element_text(angle = 90, hjust = 1))

temp_p%>%  ggplot(aes(count,r))+geom_point() +
  labs(x="Rating Count per Genres",y="Residual",title="Scatter Plot Residual vs Rating Count")

```

### Cons
There is noticeable outlier. The RMSE is 1.703 for the movie with no genres listed. Here are the records for those:

```{r}
train_set %>% filter(genres=="(no genres listed)") 
```

This model doesn't perform well with the movies if there is no genre listed. 

# 3 Results

```{r load the validation dataset,echo=FALSE}
load("../rda/validation.rda")

#Validation Set

validation_set_with_genres_breakdown <- validation  %>% left_join(genres_ref,by="genres") 
# validation  %>% left_join(genres_ref,by="genres") %>% filter(is.na(genres2))
# 
# 
# edx %>% filter(movieId==53752)
# edx %>% filter(userId==826)
# 
# genres_ref %>% filter(genres=="Drama|Horror|Mystery|Sci-Fi|Thriller")

predicted_rating <- validation_set_with_genres_breakdown %>% 
  left_join(movie_avgs,by="movieId") %>% 
  left_join(user_profile_rank_by_genres,by=c("userId","genres2")) 


predicted_rating$rank[is.na(predicted_rating$rank)]="Non-Top 1"

predicted_rating <- predicted_rating %>% 
  left_join(user_profile_avgs,by=c("userId","rank")) %>%
  mutate(predicted_rating=mu+m_i+u_i) %>% 
  group_by(userId,movieId) %>% 
  summarise(predicted_rating=mean(predicted_rating))

temp<-validation_set_with_genres_breakdown%>%
  left_join(predicted_rating,by=c("userId","movieId"))

rmse_validation <- RMSE(temp$predicted_rating,temp$rating)
```


```{r}
rmse_validation
```

## Model Summary

The simplest model consider no factor and is used as a baseline model. It has an RMSE of 1.06. 

The second model takes the movie and user rating averages into consideration. It greatly reduce the RMSE. However, it assumes the user looks at each genres without preference. The assumption is against the common sense. And the bar chart shows that the RMSE by genres is high. 

The third model improves upon model 2 by adding the user profile. The user profile analyze the historial ratings of each user. It looks at the average rating by genres for the user, and then find out which genres is most rated by the user. The model significantly improves the RMSE by recoginizing the user's preferable genres. 

# 4 Conclusion

## Summary of the report
The report starts from the simpleset model and develop by adding factors to the previous model. And I use the RMSE histogram, scatter polt and bar charts to as a guidance of what factors should be added to the model. 

I like the User Profile Model, because it takes into users' preference into consideration. 

## Limitations
The User Profile Model performs poorly with movies that have no genres listed. Fortunately, there are only very few moveis like that (one movie in our dataset). 

It also does not consider difference beween movies with single genres and multiple genres.

## Future Works
In order to improve the model, I will group the movies by genres number (how many genres are listed for the movie). Then, I will observe whether the rating is impatcted by this factor. If yes, I will build a model to include the Movie Profile. 

# 5 Reference

1 [R Markdown Cheat Sheet](https://rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf)
2 [Data Science Courses from HarvardX](https://courses.edx.org/)
